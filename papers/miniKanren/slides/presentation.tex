\documentclass[xcolor=table]{beamer}
\usepackage{beamerthemesplit}
\usepackage{wrapfig}
\usetheme{SPbGU}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{fancyvrb}
\usetikzlibrary{shapes,arrows}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{multicol}
\usepackage{comment}
\usepackage{xspace}
\usepackage{adjustbox}

\setbeamertemplate{itemize items}[circle]
\setbeamertemplate{enumerate items}[circle]

\lstdefinelanguage{ocanren}{
keywords={run, conde, fresh, let, in, match, with, when, class, type,
object, method, of, rec, repeat, until, while, \begin{comment}not,\end{comment} do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure,
true, false},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\textbf,%\ttfamily\underline,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
mathescape=true,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {function}{function}8 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\\/}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)},
 moredelim=**[is][\color{red}]{@!}{@}
}

\tikzstyle{processTree} = [
  ->,
  sibling distance=15em,
  scale=0.6,
  every node/.style = {
    shape=rectangle,
    rounded corners=0.05cm,
    draw,
    align=center,
    minimum size=5mm,
    scale=0.6,},
  %level 1/.style={sibling distance=100em}
  ]

\lstset{
language=ocanren
}

\newcommand{\mk}{\textsc{miniKanren}\xspace}
\renewcommand{\and}{$\&$\xspace}
\newcommand{\rel}[2]{\texttt{#1}$^o$ #2}
\newcommand{\subst}[1]{$\langle$#1$\rangle$}


\beamertemplatenavigationsymbolsempty

\title[Partial Deduction for \mk{}]{An Empirical Study of Partial Deduction for \mk{}}
\institute[JetBrains Research]{
JetBrains Research, Programming Languages and Tools Lab  \\
Saint Petersburg State University
}

\author[Kate Verbitskaia]{\textbf{Kate Verbitskaia}, Daniil Berezun, Dmitry Boulytchev}

\date{27.08.2020}

\definecolor{orange}{RGB}{179,36,31}

\begin{document}
{
\begin{frame}[fragile]
  \begin{tabular}{p{5.5cm} p{5.5cm}}
   \begin{center}
      \includegraphics[height=1.5cm]{pictures/jetbrainsResearch.pdf}
    \end{center}
    &
    \begin{center}
      \includegraphics[height=1.5cm]{pictures/SPbGU_Logo.png}
    \end{center}
  \end{tabular}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Partial Deduction}
  Advanced specialization technique aimed at improving the performance of relations

  \begin{center}
    \begin{minipage}[c]{0.5\textwidth}
      \input{appendoDef.tex}
    \end{minipage}
  \end{center}


  \begin{minipage}[c]{0.5\textwidth}
    \input{doubleAppDef.tex}
  \end{minipage}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Partial Deduction: Bird's-eye View}
  \begin{center}
    \adjustbox{scale=0.8}{
    \begin{minipage}[c]{0.5\textwidth}
      \input{appendoDef.tex}
    \end{minipage}}
  \end{center}

  Process tree construction

\begin{center}
  \input{appendoCPD.tex}
\end{center}

Residualization

\begin{center}
  \adjustbox{scale=0.8}{
  \begin{minipage}[c]{0.5\textwidth}
    \input{appendoRes.tex}
  \end{minipage}}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Partial Deduction}

\begin{center}
  \input{doubleAppPD.tex}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Conjunctive Partial Deduction}

\begin{center}
  \input{doubleAppCPD.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas}

\begin{center}
  \input{propDef.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas: Unfolding}

\begin{center}
  \input{propCPD.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Boolean Connectives}

\begin{center}
  \input{boolNot.tex}
\end{center}

\begin{center}
  \input{boolOr.tex}
\end{center}

\begin{center}
  \input{boolAnd.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas: Unfolding 2}

\begin{center}
  \input{propCPDunf2.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas: Unfolding 3}

\begin{center}
  \input{propCPDunf3.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas: ConsPD}

\begin{center}
  \input{propConsPD.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{\texttt{reverse}$^o$}

\begin{center}
  \input{reverseDef.tex}
\end{center}

\input{reverseCPD.tex}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Unfolding}

\begin{center}
  \input{unfold.tex}
\end{center}

\begin{center}
  \input{appendoCPD.tex}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Split}
  \begin{tikzpicture}[processTree,sibling distance=10em]
    \node {\rel{f}{$x \ y$} $\&$ \rel{g}{$x \ z$} $\&$ \rel{h}{$y \ z$}}
        child { node [diamond] {}
          child { node {\rel{f}{$x \ y$}}}
          child { node {\rel{g}{$x \ z$} $\&$ \rel{h}{$y \ z$}}}};
  \end{tikzpicture}

  \begin{tikzpicture}[processTree,sibling distance=10em]
    \node {\rel{f}{$x \ y$} $\&$ \rel{g}{$x \ z$} $\&$ \rel{h}{$y \ z$}}
      child { node [diamond] {}
        child { node {\rel{f}{$x \ y$} $\&$ \rel{g}{$x \ z$}}}
        child { node {\rel{h}{$y \ z$}}}};
  \end{tikzpicture}

  \begin{tikzpicture}[processTree,sibling distance=5em]
    \node {\rel{f}{$x \ y$} $\&$ \rel{g}{$x \ z$} $\&$ \rel{h}{$y \ z$}}
      child { node [diamond] {}
        child { node {\rel{f}{$x \ y$}}}
        child { node {\rel{g}{$x \ z$}}}
        child { node {\rel{h}{$y \ z$}}}};
  \end{tikzpicture}

  \begin{tikzpicture}[processTree,sibling distance=10em]
    \node {\rel{f}{$x \ y$} $\&$ \rel{g}{$x \ z$} $\&$ \rel{h}{$y \ z$}}
      child { node [diamond] {}
        child { node {\rel{f}{$x \ y$} $\&$ \rel{h}{$y \ z$}}}
        child { node {\rel{g}{$x \ z$}}}};
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Conservative Partial Deduction}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Branching Heuristics}


\begin{center}
  \input{appendoCPD.tex}
\end{center}


\begin{tikzpicture}[processTree]
  \node {\rel{append}{$(h::x') \ y \ r$}}
      child { node {\rel{append}{$x' \ y \ r'$ \\ \subst{$r \to h :: r'$}}}
    };
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluation}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]  :
  \frametitle{Evaluator of Logic Formulas: Order of Calls}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas: Compexity of Relations}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluator of Logic Formulas: Results}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Unification}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Path Search}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluation Results}

  \begin{table}
    \centering
    \begin{tabular}{c||c|c||c||c}
                     & last  & plain & unify  & isPath \\ \hline\hline
    Original         & 1.06s & 1.84s & ---    & ---    \\ \hline
    CPD              & ---   & 1.13s & 14.12s & 3.62s  \\ \hline
    ConsPD           & 0.93s & 0.99s & 0.96s  & 2.51s  \\ \hline
    Branching        & 3.11s & 7.53s & 3.53s  & 0.54s  \\ \hline
    \end{tabular}

    \caption{Evaluation results}
    \label{tbl:eval}
  \end{table}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Conclusion}
  \begin{itemize}
    \item Conservative Partial Deduction
    \begin{itemize}
      \item Less-branching heuristics
    \end{itemize}
    \item Evaluation shows some improvement, but not for every query
    \item Models to predict performance can help
  \end{itemize}
\end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Recognition vs. Search}
% \[ X \text{ --- alphabet}\]

% \[ L \subseteq X^* \]

% \[ if \omega \in L, \text{ denote the \emph{witness} of this fact } p_{\omega}  \]

% \pause

% \[
% \begin{array}{rl}
% \text{Recognition:} &  V(\omega, p_{\omega}) = \left\{
%   \begin{array}{lr}
%     1, &\omega \in L \\
%     0, &\omega \notin L
%   \end{array}
% \right. \\
%  & \\
% \pause

% \text{Search:} & S(\omega) = p_{\omega}
% \end{array}
% \]

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Propositional Formulas: Recognition}

% \begin{lstlisting}
% let rec eval st = function
% | Conj (l, r) -> eval st l && eval st r
% | Disj (l, r) -> eval st l || eval st r
% | Neg   e     -> not (eval st e)
% | Var   x     -> List.assoc x st

% \end{lstlisting}

% \pause

% \begin{lstlisting}

% # eval [(`x,true);(`y,false)] (Conj (Var `x) (Neg (Var `y)));;

% - : bool = true
% \end{lstlisting}

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Propositional Formulas: Search}

% \begin{lstlisting}
% let rec solve st b = function
% | Var n -> ( match assoc_opt n st with
%              | None -> [extend st n b]
%              | Some b' when b == b' -> [st]
%              | _   -> [])
% | Conj (l, r) when b ->
%     concat @@
%     map (fun st -> solve st b r) @@
%     solve st b l
% | Conj (l, r) -> solve st b l @ solve st b r
% | Neg e -> solve st (not b) e
% | Disj (l, r) -> solve st b (Neg (Conj (Neg l, Neg r)))
% \end{lstlisting}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Search is Hard\footnote{compared to recognition}}
% \begin{center}
% Is it possible to generate a search procedure from a recognizer?
% \end{center}
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Interpreter}
% \[ V^R(\omega, p_{\omega}, q) \]

% \[
% \begin{array}{ll}
%   V^R(\omega, p_{\omega}, 1), & if \omega \in L, p_{\omega} \text{ --- a witness} \\
%   & \\
%   V^R(\omega, p_{\omega}, 0), & otherwise
% \end{array}
% \]
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Interpretation for Recognition and Search}

% \[
% \begin{array}{rcl}
%  V^R(\omega, p_{\omega}, ?) & \leadsto & V(\omega, p_{\omega}) \\
%  & \\
%  V^R(\omega, ?, 1) & \leadsto & S(\omega)
% \end{array}
% \]

% \vspace*{\fill}

% \begin{center} Only one program to implement! \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Propositional Formulas: Relational Interpreter}
% \begin{comment}
% \begin{lstlisting}
% let rec eval st = function
% | Conj (l, r) -> eval st l && eval st r
% | Disj (l, r) -> eval st l || eval st r
% | Neg   e     -> not (eval st e)
% | Var   x     -> List.assoc x st

% \end{lstlisting}
% \end{comment}

% \begin{lstlisting}
% let rec eval$^o$ st fm u = ocanren (
%  fresh x, y, z, v, w in
%   fm == conj x y & eval$^o$ st x v & eval$^o$ st y w & and$^o$ v w u |
%   fm == disj x y & eval$^o$ st x v & eval$^o$ st y w & or$^o$     v w u |
%   fm == neg  x   & eval$^o$ st x v & not$^o$ v u |
%   fm == var  z   & assoc$^o$ z st u
%  )
% \end{lstlisting}

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Programming is Hard\footnote{compared to functional programming}}
% \begin{lstlisting}[basicstyle=\tiny]
% let rec hanoi$^o$ a b c moves a' b' c' = ocanren (
%  moves == [] & a == a' & b == b' & c == c' |
%  fresh f, t, moves', pin_f, pin_t, pin_f_res, pin_t_res, a'', b'', c'' in
%    moves == (f, t) :: moves' &
%    (f == A & t == B & pin_f == a & pin_f_res == a'' & pin_t == b & pin_t_res == b'' & c'' == c |
%     f == A & t == C & pin_f == a & pin_f_res == a'' & pin_t == c & pin_t_res == c'' & b'' == b |
%     f == B & t == A & pin_f == b & pin_f_res == b'' & pin_t == a & pin_t_res == a'' & c'' == c |
%     f == B & t == C & pin_f == b & pin_f_res == b'' & pin_t == c & pin_t_res == c'' & a'' == a |
%     f == C & t == A & pin_f == c & pin_f_res == c'' & pin_t == a & pin_t_res == a'' & b'' == b |
%     f == C & t == B & pin_f == c & pin_f_res == c'' & pin_t == b & pin_t_res == b'' & a'' == a) &
%    fresh top_f, rest_f in
%      pin_f == top_f :: rest_f &
%      (pin_t == [] |
%       fresh top_t, rest_t in
%         pin_t == top_t :: rest_t & lt$^o$ top_f top_t true
%      ) &
%      pin_f_res == rest_f &
%      pin_t_res == top_f :: pin_t &
%      hanoi$^o$ a'' b'' c'' moves' a' b' c'
% )
% \end{lstlisting}

% \pause

% \begin{center} It took 3 people 6 hours to implement  \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Ways to Create Relational Interpreters}
% \begin{itemize}
% 	\item Manual implementation
% 	\item \textbf<2>{Interpretation of functional programs with a relational \linebreak interpreter}
% 	\item Relational conversion
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Interpretation of Functional Programs}
% \begin{itemize}
% 	\item Implement good relational interpreter of a Turing-complete language
% 	\item Implement functional recognizer
% 	\item Run functional recognizer with a relational  interpreter
% \end{itemize}
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Interpretation Overhead}
% \begin{center}
% Running relational interpreter comes with a price
% \end{center}


% \begin{center}
% Are there ways to get rid of it?
% \end{center}

% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Specialization}
% \begin{center}

% Interpreter:

% \vspace{6pt}

% \lstinline{eval prog input} == \lstinline{output}

% \pause

% \vspace{26pt}

% Consider that a part of the input is known: \lstinline{input == (static, dynamic)}

% \vspace{26pt}
% \pause

% \begin{comment} Specializer: given a program and static input, generates a new program, which evaluates to the same output as the original

% \vspace{6pt}
% \end{comment}

% Specializer:

% \vspace{6pt}

% \lstinline{spec prog static} $\Rightarrow$ \lstinline{prog$_{spec}$}

% \lstinline{eval prog (static, dynamic) == eval prog$_{spec}$ dynamic}
% \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Jones-Optimality}
% \begin{itemize}
% 	\item Specializers can fail to remove all interpretation overhead
% 	\item Jones-optimal specializer: the specialized interpreter is as efficient as the program it was specialized for
% 	\item There exists a Jones-optimal specializer for a logical language [Leuschel,~2004]
% 	\item Not for miniKanren
% 	\item Jones-optimality is hard to achieve
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Ways to Create Relational Interpreters}
% \begin{itemize}
% 	\item Manual implementation
% 	\item Interpretation of functional programs with a relational interpreter
% 	\item \textbf{Relational conversion}
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion for Relational Interpreter}
% \begin{itemize}
%   \item Implement a functional recognizer (verifier): $V(\omega, p_{\omega})$
%   \item Transform it into a relation: $V^R(\omega, p_{\omega}, q)$
%   \item Specialize
%   \begin{itemize}
%     \item Redundancy introduced with the relational conversion
%     \item Direction ($q == 1$)
%     \item Known data ($\omega$)
%   \end{itemize}
%   \item The result is a search routine
% \end{itemize}
% \end{frame}

% \begin{comment}
% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Solvers from Verifiers}

% Relational interpeter = verifier

% Relational intepreter being run backward = solver

% \lstinline{evalo prog ?? res}

% \lstinline{is_path$^o$ path graph res}

% \lstinline{unifyo term term' subst res}

% \lstinline{run q (is_path$^o$ q graph True)} --- searches for all paths in the \lstinline{graph}

% \begin{itemize}
%   \item Implement a functional program which verifies the solution for a program
%   \item Transform it into a relation
%   \item Specialize for the backward direction
%   \item The result can search for solutions
% \end{itemize}

% \end{frame}
% \end{comment}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion (Unnesting) [Byrd 2009]}

% % Relational programming is complicated, why not let users write a verifier as a function and then translate it into miniKanren?

% \begin{itemize}
%   \item Introduce a new variable for each subexpression
%   \item For every n-ary function create an (n+1)-ary relation, where the last argument is unified with the result
%   \item Transform \lstinline{if}-expressions and pattern matchings into disjunctions with unifications for patterns
%   \item Introduce into scope free variables (with \lstinline{fresh})
%   \item Pop unifications to the top
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion: Step 1}
% \begin{center}
% Introduce a new variable for each subexpression
% \end{center}

% \begin{columns}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append a b =
%   match a with
%   | []      -> b
%   | x :: xs ->
%     x :: append xs b
% \end{lstlisting}
% \end{column}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append a b =
%   match a with
%   | []      -> b
%   | x :: xs ->
%     let @!q@ = append xs b in
%     x :: @!q@
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion: Step 2}
% \begin{center}
% Introduce a new argument for result
% \end{center}

% \begin{columns}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append a b = ...
% \end{lstlisting}
% \end{column}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append$^o$ a b @!c@ = ...
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion: Step 3}

% \begin{center}
% Transform \lstinline{if}-expressions and pattern matchings into disjunctions with unifications for patterns
% \end{center}

% \begin{columns}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append a b =
%   match a with
%   | []      -> b
%   | x :: xs ->
%     let q = append xs b in
%     x :: q
% \end{lstlisting}
% \end{column}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append$^o$ a b c =
%   ocanren (
%     (a == [] & b == c) |
%     (  a == x :: xs &
%        append$^o$ xs b q &
%        c == x :: q))
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion: Step 4}
% \begin{center}
% Introduce free variables into scope  (with \lstinline{fresh})
% \end{center}

% \begin{columns}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append$^o$ a b c =
%   ocanren (
%     (a == [] & b == c) |
%     (  (a == x :: xs) &
%        (append$^o$ xs b q) &
%        (c == x :: q)))
% \end{lstlisting}
% \end{column}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append$^o$ a b c =
%   ocanren (
%     (a == [] & b == c) |
%     (@!fresh x, xs, q in@
%        a == x :: xs &
%        append$^o$ xs b q &
%        c == x :: q))
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion: Step 5}
% \begin{center}
% Pop unifications to the top
% \end{center}

% \begin{columns}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append$^o$ a b c =
%   ocanren (
%     (a == [] & b == c) |
%     (fresh x, xs, q in
%        a == x :: xs &
%        append$^o$ xs b q &
%        c == x :: q))
% \end{lstlisting}
% \end{column}
% \begin{column}{0.5\textwidth}
% \begin{lstlisting}
% let rec append$^o$ a b c =
%   ocanren (
%     (a == [] & b == c) |
%     (fresh x, xs, q in
%        a == x :: xs &
%        @!c == x :: q@ &
%        append$^o$ xs b q))
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Forward Execution is Efficient, Backward Execution is not}

%   Forward execution is efficient, since it mimics the execution of a function

% \vspace{6pt}

% Relational conversion for \lstinline{f$_1$ x$_1$ && f$_2$ x$_2$}:

% \begin{lstlisting}
% fun res -> ocanren (
%   fresh p in
%      f$_1$ x$_1$ p &
%      ( p == false & res == false |
%        p == true  & f$_2$ x$_2$ res))
% \end{lstlisting}

% Computes \lstinline{f$_2$ x$_2$ res} only if \lstinline{f$_1$ x$_1$ p} fails

% \vspace{6pt}

% It is not the best strategy, if \lstinline{res} is known

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Relational Conversion Aimed at Backward Execution}

% This coversion of  \lstinline{f$_1$ x$_1$ && f$_2$ x$_2$} is better for the backward execution, but not for forward

% \begin{lstlisting}
% fun res -> ocanren (
%   res == false & f$_1$ x$_1$ false |
%   f$_1$ x$_1$ true    & f$_2$ x$_2$ res)
% \end{lstlisting}


%   There is no single strategy suitable for all cases
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{There is no Single Good Strategy}

% \begin{center}
% Is there a way to automatically generate relations efficient in the specified directions?
% \end{center}

% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Specialization: Not Only for Direction}
% \begin{center} When solving a search problem, we know its search space  \end{center}

% \[  V^R(\omega, ?, 1) \leadsto S(\omega) \]
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Partial Deduction: Specialization for Logic Language}
% \begin{itemize}
% 	\item Given:
% 	\begin{itemize}
% 		\item Logic program
% 		\item Goal
% 	\end{itemize}
% 	\item Result: specialized program
% 	\item How:
% 	\begin{itemize}
% 		\item Construct a \emph{partial} SLD-tree
% 		\item Generate a program from the tree
% 	\end{itemize}
% 	\item Hopefully, all excessive computations are done statically and do not come to the specialized program
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Partial Deduction: Example}
% \begin{columns}
% \begin{column}{0.55\textwidth}
% \begin{lstlisting}
% last([x|xs], r) $\leftarrow$ l(xs, x, r).
% l([], x, x).
% l([z|zs], x, r) $\leftarrow$ l(zs, z, r).

% $\leftarrow$ last([A,B|xs], r).
% \end{lstlisting}
% \end{column}
% \begin{column}{0.45\textwidth}
% \begin{center}
% \pause

% \begin{forest}
% [{$last([A,B|xs], r)$} [{$l([B|xs], A, r)$} [{$l(xs, B, r)$} [{$\square$}] [{$l(zs', z', r)$}] ] ] ]
% \end{forest}
% \end{center}
% \end{column}
% \end{columns}

%   \pause

% \begin{center}
% \begin{minipage}{0.7\textwidth}
% \begin{lstlisting}
% last([A,B], B).
% last([A,B,z'|zs'], r) $\leftarrow$ l(zs', z', r).
% l([], x, x).
% l([z|zs], x, r) $\leftarrow$ l(zs, z, r).
% \end{lstlisting}
% \end{minipage}
% \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Partial Deduction: Conjunctions}
% \begin{columns}
% \begin{column}{0.5\textwidth}

% \begin{center}
% \begin{forest}
% [{$f(x, y) \vee f(y, z)$} [{$f(x, y)$}] [{$f(y, z)$}] ]
% \end{forest}

% \vspace{3em}

% $\Large\color{green}{\checkmark}$
% \end{center}

% \end{column}

% \pause

% \begin{column}{0.5\textwidth}

% \begin{center}
% \begin{forest}
% [{$f(x, y) \wedge f(y, z)$} [{$f(x, y)$}] [{$f(y, z)$}] ]
% \end{forest}

% \vspace{3em}

% $\Large\color{red}{X}$
% \end{center}

% \end{column}
% \end{columns}
% \end{frame}



% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Conjunctive Partial Deduction}
% \begin{itemize}
%   \item Fully automatic program transformation
%   \item For pure logic language
%   \item Features:
%   \begin{itemize}
%     \item Specialization
%     \item Deforestation
%     \item Tupling
%   \end{itemize}
% \end{itemize}
% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Deforestation}
% Deforestation --- program transformation which eliminates intermediate data structures

% \begin{columns}
% \begin{column}{0.45\textwidth}
% \begin{lstlisting}[basicstyle=\footnotesize]
% let double_append$^o$ x y z xyz =
%   ocanren (
%     fresh @!t@ in
%       append$^o$ x y @!t@ &
%       append$^o$ @!t@ z xyz )

% let rec append$^o$ x y xy =
%   ocanren (
%     x == [] & xy == y |
%     fresh h, t, ty in
%       x  == h :: t  &
%       xy == h :: t' &
%       append$^o$ t y t')
% \end{lstlisting}
% \end{column}
% \begin{column}{0.55\textwidth}
% \begin{lstlisting}[basicstyle=\footnotesize]
% let rec double_append$^o$ x y z xyz =
%   ocanren (
%     x == [] & append$^o$ y z xyz |
%     (fresh h, t, t' in
%        x == h :: t  &
%        xyz == h :: t' &
%        double_append$^o$ t y z t')
% \end{lstlisting}
% \end{column}
% \end{columns}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Tupling}
% Tupling --- program transformation which eliminates multiple traversals of the same data structure

% \begin{lstlisting}[basicstyle=\footnotesize]
% let max_length$^o$ xs m l = ocanren (max$^o$ xs m & length$^o$ xs l)

% let rec length$^o$ xs l = ocanren (
%   xs == [] & l == 0 |
%   (fresh h, t, m in
%     xs == h :: t & l == succ m & length$^o$ t m))

% let max$^o$ xs m = max$_1^o$ xs 0 m

% let rec max$_1^o$ xs n m = ocanren (
%   xs == [] & m == n |
%   (fresh h, t in
%     xs == h :: t &
%     ( le$^o$ h n true & max$_1^o$ t n m |
%       gt$^o$ h n true & max$_1^o$ t h m)))
% \end{lstlisting}

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Tupling}
% Tupling --- program transformation which eliminates multiple traversals of the same data structure

% \begin{lstlisting}[basicstyle=\footnotesize]
% let max_length$^o$ xs m l = ocanren (max_length$_1^o$ xs m 0 l)

% let rec max_length$_1^o$ xs m n l = ocanren (
%   xs == [] & m == n & l == 0 |
%   (fresh h, t, l$_1$ in
%      xs == h :: t &
%      l == succ l$_1$ &
%      ( le$^o$ h n & max_length$_1^o$ t m n l |
%        gt$^o$ h n & max_length$_1^o$ t m h l)))
% \end{lstlisting}


% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{CPD: Intuition}
% \begin{itemize}
%   \item Local control: compute a partial SLD-tree per a relation of interest
%   \begin{itemize}
%     \item Having a conjunction of atoms, which atom should be selected?
%     \item When to stop building a tree?
%   \end{itemize}
%   \item Global control: determine which relations are of interest
%   \begin{itemize}
%     \item Do not process the same conjunction twice
%     \item If a conjunction \textit{embeds} something processed before, \textit{generalize} it
%     \item How to define \textit{embedding}?
%     \item How to \textit{generalize}?
%   \end{itemize}
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{CPD: Implementation}
% \begin{itemize}
%   \item Local control
%   \begin{itemize}
%     \item Deterministic unfold (only one nondeterministic unfold per tree)
%     \item Selectable conjunct: leftmost call which does not have any predecessor embedded into it
%     \item Variant check
%     \item Stop when there are no selectable conjuncts
%   \end{itemize}
%   \item Global control
%   \begin{itemize}
%     \item Variant check
%     \item Generalization: split conjunction in maximally connected subconjunctions + most specific generalization
%     \item Homeomorphic embedding extended for conjunctions
%   \end{itemize}
%   \item Residualization
%   \begin{itemize}
%     \item A definition per a local tree
%     \item Redundant Argument Filtering
%   \end{itemize}
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Evaluation}
%   Compare

% \begin{itemize}
%   \item Unnesting
%   \item Unnesting strategy aimed at backward execution
%   \item Unnesting + CPD
%   \item Interpretation of functional verifier with relational interpreter
% \end{itemize}

% Tasks

% \begin{itemize}
%   \item Path search
%   \item Search for a unifier of two terms
% \end{itemize}

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Path Search}

% \emph{Directed graph} is a tuple $(N, E, start, end)$, where:

% \begin{itemize}
% 	\item $N$ --- set of nodes
% 	\item $E$ --- set of edges
% 	\item Functions $start, end: E \rightarrow N$ return a start (end) node of an edge
% \end{itemize}

% \pause
% \vspace{10pt}

% \emph{Path} is a sequence $\langle n_0, e_0, n_1, e_1, \dots, n_k, e_k, n_{k+1} \rangle$, such that
% \[
% \forall i \in \{ 0 \dots k \}\; :\; n_i = start\,(e_i) \text{ and } n_{i+1} = end\,(e_i)
% \]

% \vspace{10pt}

% \pause
% \emph{Path search problem} is to find the set of paths in a given graph

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Path Search: Relational Conversion }

% \begin{lstlisting}[numbers=left,numberstyle=\small]
% let rec is_path ns g =
%   match ns with
%   | x$_1$ :: x$_2$ :: xs ->   elem (x$_1$, x$_2$) g && is_path (x$_2$ :: xs) g
%   | [_]            -> true
% \end{lstlisting}

% \pause

% \begin{lstlisting}[]
% let rec is_path$^o$ ns g res = ocanren (
%   fresh el in (ns == [el]  & res == true) |
%   (fresh x$_1$, x$_2$, xs, res_elem, res_is_path in
%     ns == x$_1$ :: (x$_2$ :: xs) &
%     elem$^o$ (x$_1$, x$_2$) g res_elem &
%     is_path$^o$ (x$_2$ :: xs) g res_is_path &
%     ( res_elem == false & res == false |
%       res_elem == true  & res == res_is_path )))
% \end{lstlisting}

% This relation is inefficient for ``\lstinline{is_path$^o$ q <graph> true}''

% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Path Search: Specialized Relation}

% \begin{lstlisting}[]
% let rec is_path$^o$ ns g res = ocanren (
%   fresh el in (ns == [el] & res == true) |
%   (fresh x$_1$, x$_2$, xs, res_elem, res_is_path in
%     res_elem == true &
%     res_is_path == true &
%     ns == x$_1$ :: (x$_2$ :: xs) &
%     elem$^o$ (x$_1$, x$_2$) g res_elem &
%     is_path$^o$ (x$_2$ :: xs) g res_is_path)))
% \end{lstlisting}

% \vspace{16pt}

% Better performance for ``\lstinline{is_path$^o$ q <graph> true}''

% \pause
% \vspace{10pt}

% This can be achieved automatically with CPD


% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Evaluation: Path Search}

% \begin{table}
% \footnotesize
% \centering
% \begin{tabular}{c|c|c|c|c|c|c}
% Path length                   & 5      & 7     & 9      & 11      & 13     & 15        \\
% \hline\hline
% Only conversion               & 0.01  & 1.39 &  82.13 & >300     & ---      & ---     \\
% \hline
% Backward oriented conversion  & 0.01 & 0.37 &  2.68 & 2.91   & 4.88    & 10.63   \\
% \hline
% Conversion and CPD            & 0.01  & 0.06 &  0.34 & 2.66   & 3.65    & 6.22  \\
% \hline
% Scheme interpreter            & 0.80  & 8.22 & 88.14 & 191.44 & >300   & ---   \\
% \end{tabular}

%  \caption{Searching for paths in the graph (seconds)}
%     \label{tab:is_path}
% \end{table}
% \end{frame}



% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Unification}

% \emph{Term}:
% \begin{itemize}
% 	\item Variable ($X, Y, \dots$)
% 	\item Some constructor applied to terms ($nil, cons(H, T), \dots$)
% \end{itemize}

% \pause
% \vspace{10pt}

% \emph{Substitution} maps variables to terms

% \vspace{10pt}

% Substitution can be \emph{applied} to a term by simultaneously substituting variables for their images

% \vspace{10pt}
% \pause

% \emph{Unifier} is a substitution $\sigma$ which equalizes terms: $t \sigma = s \sigma$

% \vspace{10pt}

% \pause
% Problem: given two terms with free variables, find their unifier

% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Unification: Functional Verifier}

% \begin{comment}
%   let rec forall2 subst l1 l2 =
%     match l1, l2 with
%     | []   , []    -> true
%     | x::xs, y::ys -> check_uni subst x y &&
%                       forall2 subst xs ys in
% \end{comment}

% \begin{lstlisting}[basicstyle=\footnotesize]
% let rec check_uni subst t1 t2 =
%   match t1, t2 with
%   | Constr (n1, a1), Constr (n2, a2) ->
%       eq_nat n1 n2 && forall2 subst a1 a2
%   | Var_ v         , Constr (n, a)   ->
%     begin match get_term v subst with
%     | None   -> false
%     | Some t -> check_uni subst t t2
%     end
%   | Constr (n, a)  , Var_ v          ->
%     begin match get_term v subst with
%     | None   -> false
%     | Some t -> check_uni subst t1 t
%     end
%   | Var_ v1        , Var_ v2         ->
%     match get_term v1 subst with
%     | Some t1' -> check_uni subst t1' t2
%     | None     -> match get_term v2 subst with
%                   | Some _ -> false
%                   | None   -> eq_nat v1 v2
% \end{lstlisting}

% \end{frame}
% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Unification: Relational Conversion}
% Does not fit the slide.


% \end{frame}


% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Evaluation: Unification}
% \begin{table}
% \tiny
% \centering
% \begin{tabular}{c|c|c|c}
% \multirow{ 2}{*}{Terms} &
% f(X, a) & f(a \% b \% nil, c \% d \% nil, L) & f(X, X, g(Z, t))  \\
% \cline{2-4} &
% f(a, X) & f(X \% XS, YS, X \% ZS) & f(g(p, L), Y, Y)  \\
% \hline\hline
% Only conversion               & 0.01  &  >300 & >300 \\
% \hline
% Backward oriented conversion  & 0.01  &  0.11 & 2.26  \\
% \hline
% Conversion and CPD            & 0.01  &  0.07 & 0.90  \\
% \hline

% Scheme interpreter            & 0.04  & 5.15 & >300   \\
% \end{tabular}
%  \caption{Searching for a unifier of two terms (seconds)}
%     \label{tab:uni}
% \end{table}
% \end{frame}

% \begin{frame}[fragile]
%   \transwipe[direction=90]
%   \frametitle{Conclusion \& Future Work}
% \begin{center}
% Functional recognizer + unnesting + specialization = search
% \end{center}

% \vspace{15pt}

% Future work

% \begin{itemize}
%   \item Generate functional program from relational to reduce interpretation overhead
%   \item Some other specialization technique, less ad-hoc than CPD

% \end{itemize}
% \end{frame}

\end{document}
