\documentclass[xcolor=table]{beamer}
\usepackage{beamerthemesplit}
\usepackage{wrapfig}
\usetheme{SPbGU}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,automata,positioning,quotes,backgrounds,decorations.text,decorations.pathmorphing}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{fancyvrb}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{multicol}
\usepackage{comment}
\usepackage{xspace}
\usepackage{adjustbox}
\usepackage{makecell}

\setbeamertemplate{itemize items}[circle]
\setbeamertemplate{enumerate items}[circle]

\lstdefinelanguage{ocanren}{
keywords={run, conde, fresh, let, in, match, with, when, class, type,
object, method, of, rec, repeat, until, while, \begin{comment}not,\end{comment} do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure,
true, false},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\textbf,%\ttfamily\underline,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
mathescape=true,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {function}{function}8 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\\/}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)},
 moredelim=**[is][\color{red}]{@!}{@}
}

\tikzstyle{processTree} = [
  ->,
  sibling distance=15em,
  scale=0.6,
  every node/.style = {
    shape=rectangle,
    rounded corners=0.05cm,
    draw,
    align=center,
    minimum size=5mm,
    scale=0.6,},
  %level 1/.style={sibling distance=100em}
  ]


\tikzstyle{program} = [
  draw=black,
  thick,
  rectangle,
  rounded corners=1pt,
  inner sep=5pt,
  inner ysep=5pt
  ]

\tikzstyle{goal} = [
  draw=black,
  rectangle,
  rounded corners=1pt,
  inner ysep=0pt,
  ]

\tikzstyle{input} = [
  draw=none,
  rectangle,
  rounded corners=1pt,
  inner sep=2pt,
  inner ysep=2pt,
  fill=green!10,
  minimum height=5mm
  ]


\tikzstyle{transparent} = [
  draw=none,
  inner ysep=3pt
  ]

\lstset{
language=ocanren
}

\newcommand{\mk}{\textsc{miniKanren}\xspace}
\renewcommand{\and}{$\&$\xspace}
\newcommand{\rel}[2]{\texttt{#1}$^o$ #2}
\newcommand{\subst}[1]{$\langle$#1$\rangle$}

\beamertemplatenavigationsymbolsempty

\title[Partial Deduction for \mk{}]{An Empirical Study of Partial Deduction for \mk{}}
\institute[JetBrains Research]{
JetBrains Research, Programming Languages and Tools Lab  \\
Saint Petersburg State University
}

\author[Kate Verbitskaia]{\textbf{Kate Verbitskaia}, Daniil Berezun, Dmitry Boulytchev}

\date{27.08.2020}

\definecolor{orange}{RGB}{179,36,31}

\begin{document}
{
\begin{frame}[fragile]
  \begin{tabular}{p{5.5cm} p{5.5cm}}
   \begin{center}
      \includegraphics[height=1.5cm]{pictures/jetbrainsResearch.pdf}
    \end{center}
    &
    \begin{center}
      \includegraphics[height=1.5cm]{pictures/SPbGU_Logo.png}
    \end{center}
  \end{tabular}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
  \frametitle{Specialization: a Method to Improve Programs}
\begin{center}
  \input{spec.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Partial Deduction: Specialization for Logic Programming}
\begin{center}
  \input{pd.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Partial Deduction for \mk: Bird's-eye View}
  \begin{center}
\input{birdseye.tex}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Driving: Unfolding}
  \begin{center}
    \input{drivingUnfold.tex}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Partial Deduction}

\begin{center}
  \input{pd1.tex}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Conjunctive Partial Deduction}

\begin{center}
  \input{cpd1.tex}
\end{center}
\end{frame}


\begin{frame}[fragile]
  \frametitle{CPD: Split is Necessary}

\begin{tikzpicture}[
  remember picture,
  overlay
]
 \node (a) [
   program,
   anchor=north west,
   xshift=0.4cm,
   yshift=-1.4cm
 ]
 at (current page.north west)
 {
   \adjustbox{scale=0.6}
   {
     \begin{minipage}[c]{0.4\textwidth}
       \input{reverseDef.tex}
     \end{minipage}
   }};

 \node [
     goal,
     anchor=north east,
   ]
   at (a.south east)
   {
     \adjustbox{scale=0.6}
     {
       \begin{minipage}[c]{0.25\textwidth}
         \begin{lstlisting}
reverse$^o$ xs sx
         \end{lstlisting}
       \end{minipage}
     }};

\node [
  transparent,
  anchor=south west,
  yshift=0.5cm,
  xshift=0.4cm
  ]
  at (current page.south west)
  {
      \input{reverseSplit.tex}
  };

 \node [
   transparent,
   anchor=south east,
   yshift=2.5cm,
   xshift=-0.4cm
 ]
 at (current page.south east)
 {
     \input{reverseCPD.tex}
 };
\end{tikzpicture}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Decisions in Partial Deduction}
\begin{itemize}
  \item What to unfold: which calls, how many calls?
  \begin{itemize}
    \item CPD: the leftmost call, which does not have a predecessor \emph{embedded} into it
  \end{itemize}
  \item How to unfold: to what depth a call should be unfolded?
  \begin{itemize}
    \item CPD: unfold once
  \end{itemize}
  \item When to stop driving?
  \begin{itemize}
    \item When a goal is an instance of some goal in the process tree
  \end{itemize}
  \item When to split?
  \begin{itemize}
    \item When there is a predecessor embedded into the goal
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas: Unfolding Step 1}

\begin{tikzpicture}[
  remember picture,
  overlay
]
  \node (a) [
    program,
    anchor=north west,
    xshift=0.4cm,
    yshift=-1.4cm
  ]
  at (current page.north west)
  {
    \adjustbox{scale=0.6}
    {
      \begin{minipage}[c]{\textwidth}
        \input{propDef.tex}
      \end{minipage}
    }};

  \node [
      goal,
      anchor=north east,
    ]
    at (a.south east)
    {
      \adjustbox{scale=0.6}
      {
        \begin{minipage}[c]{0.25\textwidth}
          \begin{lstlisting}
eval$^o$ fm s true
          \end{lstlisting}
        \end{minipage}
      }};

  \node [
    transparent,
    anchor=south,
    yshift=1cm,
  ]
  at (current page.south)
  {
      \input{propCPD.tex}
  };
\end{tikzpicture}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas: Unfolding Step 2}

\begin{center}
  \input{propCPDunf2.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unfolding of Boolean Connectives}

  \begin{center}
    \input{boolOr.tex}
  \end{center}

  \vspace{1cm}

  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{center}
        \input{boolNot.tex}
      \end{center}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{center}
        \input{boolAnd.tex}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Unfolding Boolean Connectives First}

\begin{center}
  \input{propCPDunf3.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas: Conservative PD}

\begin{center}
  \input{propConsPD.tex}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Split: Which Way is the Right Way?}
\input{split.tex}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conservative Partial Deduction}
\begin{itemize}
  \item Split conjunction into individual calls
  \item Unfold each call in isolation
  \item Unfold until embedding is encountered
  \item Find a call which narrows the search state (less-branching heuristics)
  \item Join the result of unfolding the selected call with the other calls not unfolded
  \item Continue driving the constucted conjunction
\end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Less-branching Heuristics}

  \begin{center}
    Less-branching heuristics is used to select a call to unfold

    \vspace{0.5cm}

    If the call has less branches in the process tree than the relation can possible have, unfold the call
  \end{center}

\vspace{0.5cm}


  \begin{columns}
    \begin{column}[]{0.65\textwidth}
      \begin{center}
        \input{appendoCPD.tex}
      \end{center}
    \end{column}
    \begin{column}[]{0.35\textwidth}
      \begin{center}
        \begin{tikzpicture}[processTree]
          \node {\rel{append}{$(h::x') \ y \ r$}}
              child { node {\rel{append}{$x' \ y \ r'$ \\ \subst{$r \to h :: r'$}}}
            };
        \end{tikzpicture}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation}
We implemented the Conservative Partial Deduction and compared it with CPD for \mk and CPD with branching heuristics on the following relations

\begin{itemize}
  \item Two implementations of an evaluator of logic formulas
  \item A program to compute a unifier of two terms
  \item A program to search for paths of a specific length in a graph
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas}
    \begin{center}
      \adjustbox{scale=0.9}
      {
        \begin{minipage}[c]{\textwidth}
          \input{propDef.tex}
        \end{minipage}
      }
    \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas: Order of Calls}
  \begin{tikzpicture}[remember picture, overlay]

    \node (a) [
      transparent,
      anchor=north west,
      xshift=0.4cm,
      yshift=-1.8cm
    ]
    at (current page.north west)
    {
      \adjustbox{scale=0.8}
      {
        \begin{minipage}[c]{0.9\textwidth}
          \input{propDef1.tex}
        \end{minipage}
      }
    };

    \node (b) [
      transparent,
      anchor=south west]
      at (a.north west)
    {\footnotesize
        boolean connective first
    };

    \pause

    \node (c) [
      transparent,
      anchor=south east,
      xshift=-1.3cm,
      yshift=0.5cm
    ]
    at (current page.south east)
    {
      \adjustbox{scale=0.8}
      {
        \begin{minipage}[c]{0.9\textwidth}
          \input{propDef.tex}
        \end{minipage}
      }
    };

    \node (d) [
      transparent,
      anchor=south west]
      at (c.north west)
    {\footnotesize
      boolean connective last
    };
  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas: Compexity of Relations}


  \begin{tikzpicture}[remember picture, overlay]

    \node (a) [
      transparent,
      anchor=north west,
      xshift=0.4cm,
      yshift=-1.8cm
    ]
    at (current page.north west)
    {
      \adjustbox{scale=0.7}
      {
        \begin{minipage}[c]{0.8\textwidth}
          \input{orDef.tex}
        \end{minipage}
      }
    };

    \node (b) [
      transparent,
      anchor=south]
      at (a.north)
    {\footnotesize
        table-based implementation
    };

    \pause

    \node (c) [
      transparent,
      anchor=south east,
      xshift=-0.4cm,
      yshift=0.5cm
    ]
    at (current page.south east)
    {
      \adjustbox{scale=0.7}
      {
        \begin{minipage}[c]{0.8\textwidth}
          \input{orDef1.tex}
        \end{minipage}
      }
    };

    \node (d) [
      transparent,
      anchor=south]
      at (c.north)
    {\footnotesize
        implementation via nand$^o$
    };
  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluator of Logic Formulas: Evaluation}
Implementations:

\begin{itemize}
  \item \emph{last}: boolean connectives last, implemented via \lstinline{nand$^o$}
  \item \emph{plain}: boolean connectives first, straightforward implementation
\end{itemize}


\begin{table}
  \centering
  \begin{tabular}{c||c|c}
                   & last  & plain  \\ \hline\hline
  Original         & 1.06s & 1.84s  \\ \hline
  CPD              & ---   & 1.13s  \\ \hline
  ConsPD           & 0.93s & 0.99s  \\ \hline
  Branching        & 3.11s & 7.53s  \\ \hline
  \end{tabular}

  \caption{Evaluation results}
\end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unification}
Relation to find a unifier of two terms

\vspace{0.5cm}

Query: unification of terms $f (X, X, g(Z,t))$ and $f (g(p,L),Y,Y)$
\end{frame}

\begin{frame}[fragile]
  \frametitle{Path Search}
Relation to search for paths in a graph

\vspace{0.5cm}

Query: find 5 paths in a graph with 20 vertices and 30 edges

\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Results}

  \begin{table}
    \centering
    \begin{tabular}{c||c|c||c||c}
                     & last  & plain & unify  & isPath \\ \hline\hline
    Original         & 1.06s & 1.84s & ---    & ---    \\ \hline
    CPD              & ---   & 1.13s & 14.12s & 3.62s  \\ \hline
    ConsPD           & 0.93s & 0.99s & 0.96s  & 2.51s  \\ \hline
    Branching        & 3.11s & 7.53s & 3.53s  & 0.54s  \\ \hline
    \end{tabular}

    \caption{Evaluation results}
  \end{table}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Conclusion}
  \begin{itemize}
    \item We developped and implemented Conservative Partial Deduction
    \begin{itemize}
      \item Less-branching heuristics
    \end{itemize}
    \item Evaluation shows some improvement, but not for every query
    \item Future work:
    \begin{itemize}
      \item Develop models to predict execution time
      \item Develop specialization which is more predictable, stable and well-behaved
    \end{itemize}
  \end{itemize}
\end{frame}


\end{document}
